import fs from 'fs-extra'
import pico from 'picocolors'
import webpack from 'webpack'
import WebpackDevServer from 'webpack-dev-server'

import {
  createCompiler,
  prepareProxy,
  prepareUrls,
} from '../../common/utils/webpackDevServerUtils.mjs'
import evalSourceMapMiddleware from '../../common/utils/evalSourceMapMiddleware.mjs'
import noopServiceWorkerMiddleware from '../../common/utils/noopServiceWorkerMiddleware.mjs'
import createRedirectServedPathMiddleware from '../../common/utils/redirectServedPathMiddleware.mjs'
import ignoredFiles from '../../common/utils/ignoredFiles.mjs'
import choosePort from '../../common/utils/choosePort.mjs'
import openBrowser from '../../common/utils/openBrowser.mjs'
import checkRequiredFiles from '../../common/utils/checkRequiredFiles.mjs'
import { getUserConfig } from '../config/getUserConfig.mjs'
import { getPaths } from '../../common/getPaths.mjs'
import { getWebpackConfig } from '../config/webpack.config.mjs'
import { applyEnv } from '../../common/getEnv.mjs'
import { getLocalHost } from '../../common/utils/index.mjs'

process.on('unhandledRejection', (err) => {
  throw err
})

const dev = async (mode: string) => {
  try {
    const userConfig = await getUserConfig()
    const paths = getPaths(userConfig)

    applyEnv(mode, 'development', paths)

    const {
      server: { https },
    } = userConfig

    // Warn and crash if required files are missing
    if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {
      process.exit(1)
    }

    const useLocalHost = process.env.USE_LOCAL_HOST === 'true'

    const protocol = https ? 'https' : 'http'
    const defaultPort = Number(process.env.PORT || '3000')
    const host = (useLocalHost && getLocalHost()) || '0.0.0.0'

    const sockHost = process.env.WDS_SOCKET_HOST || undefined
    const sockPath = process.env.WDS_SOCKET_PATH || undefined
    const sockPort = process.env.WDS_SOCKET_PORT || undefined

    // We attempt to use the default port but if it is busy, we offer the user to
    // run on a different port. `choosePort()` Promise resolves to the next free port.
    const port = await choosePort(host, defaultPort)

    if (port == null) {
      // We have not found a port.
      console.log(pico.red('No port found, please check your environment'))
      return
    }

    const config = await getWebpackConfig(userConfig, paths)
    const appName = require(paths.appPackageJson).name
    const urls = prepareUrls(
      protocol,
      host,
      port,
      paths.publicUrlOrPath.slice(0, -1),
    )

    // Create a webpack compiler that is configured with custom messages.
    const compiler = createCompiler({
      appName,
      config,
      urls,
      webpack,
    })
    // Load proxy config
    const proxySetting = require(paths.appPackageJson).proxy
    const proxyConfig = prepareProxy(
      proxySetting,
      paths.appPublic,
      paths.publicUrlOrPath,
    )

    const disableFirewall =
      !proxyConfig || process.env.DANGEROUSLY_DISABLE_HOST_CHECK === 'true'

    // Serve webpack assets generated by the compiler over a web server.
    const serverConfig:
      | webpack.Compiler
      | webpack.MultiCompiler
      | WebpackDevServer.Configuration
      | undefined = {
      // WebpackDevServer 2.4.3 introduced a security fix that prevents remote
      // websites from potentially accessing local content through DNS rebinding:
      // https://github.com/webpack/webpack-dev-server/issues/887
      // https://medium.com/webpack/webpack-dev-server-middleware-security-issues-1489d950874a
      // However, it made several existing use cases such as development in cloud
      // environment or subdomains in development significantly more complicated:
      // https://github.com/facebook/create-react-app/issues/2271
      // https://github.com/facebook/create-react-app/issues/2233
      // While we're investigating better solutions, for now we will take a
      // compromise. Since our WDS configuration only serves files in the `public`
      // folder we won't consider accessing them a vulnerability. However, if you
      // use the `proxy` feature, it gets more dangerous because it can expose
      // remote code execution vulnerabilities in backends like Django and Rails.
      // So we will disable the host check normally, but enable it if you have
      // specified the `proxy` setting. Finally, we let you override it if you
      // really know what you're doing with a special environment variable.
      // Note: ["localhost", ".localhost"] will support subdomains - but we might
      // want to allow setting the allowedHosts manually for more complex setups
      allowedHosts: disableFirewall ? 'all' : [urls.lanUrlForConfig as string],
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': '*',
        'Access-Control-Allow-Headers': '*',
      },
      // Enable gzip compression of generated files.
      compress: true,
      static: {
        // By default WebpackDevServer serves physical files from current directory
        // in addition to all the virtual build products that it serves from memory.
        // This is confusing because those files wonâ€™t automatically be available in
        // production build folder unless we copy them. However, copying the whole
        // project directory is dangerous because we may expose sensitive files.
        // Instead, we establish a convention that only files in `public` directory
        // get served. Our build script will copy `public` into the `build` folder.
        // In `index.html`, you can get URL of `public` folder with %PUBLIC_URL%:
        // <link rel="icon" href="%PUBLIC_URL%/favicon.ico">
        // In JavaScript code, you can access it with `process.env.PUBLIC_URL`.
        // Note that we only recommend to use `public` folder as an escape hatch
        // for files like `favicon.ico`, `manifest.json`, and libraries that are
        // for some reason broken when imported through webpack. If you just want to
        // use an image, put it in `src` and `import` it from JavaScript instead.
        directory: paths.appPublic,
        publicPath: [paths.publicUrlOrPath],
        // By default files from `contentBase` will not trigger a page reload.
        watch: {
          // Reportedly, this avoids CPU overload on some systems.
          // https://github.com/facebook/create-react-app/issues/293
          // src/node_modules is not ignored to support absolute imports
          // https://github.com/facebook/create-react-app/issues/1065
          ignored: ignoredFiles(paths.appSrc),
        },
      },
      client: {
        webSocketURL: {
          // Enable custom sockjs pathname for websocket connection to hot reloading server.
          // Enable custom sockjs hostname, pathname and port for websocket connection
          // to hot reloading server.
          hostname: sockHost,
          pathname: sockPath,
          port: sockPort,
        },
        overlay: {
          errors: true,
          warnings: false,
        },
      },
      devMiddleware: {
        // It is important to tell WebpackDevServer to use the same "publicPath" path as
        // we specified in the webpack config. When homepage is '.', default to serving
        // from the root.
        // remove last slash so user can land on `/test` instead of `/test/`
        publicPath: paths.publicUrlOrPath.slice(0, -1),
      },
      https: false,
      host,
      port,
      historyApiFallback: {
        // Paths with dots should still use the history fallback.
        // See https://github.com/facebook/create-react-app/issues/387.
        disableDotRule: true,
        index: paths.publicUrlOrPath,
      },
      // `proxy` is run between `before` and `after` `webpack-dev-server` hooks
      proxy: proxyConfig,
      setupMiddlewares: (middlewares, devServer: any) => {
        if (!devServer) {
          throw new Error('webpack-dev-server is not defined')
        }

        // Keep `evalSourceMapMiddleware`
        // middlewares before `redirectServedPath` otherwise will not have any effect
        // This lets us fetch source contents from webpack for the error overlay
        devServer.app.use(evalSourceMapMiddleware(devServer))

        if (fs.pathExistsSync(paths.proxySetup)) {
          // This registers user provided middleware for proxy reasons
          require(paths.proxySetup)(devServer.app)
        }

        // Redirect to `PUBLIC_URL` or `homepage` from `package.json` if url not match
        devServer.app.use(
          createRedirectServedPathMiddleware(paths.publicUrlOrPath),
        )

        // This service worker file is effectively a 'no-op' that will reset any
        // previous service worker registered for the same host:port combination.
        // We do this in development to avoid hitting the production cache if
        // it used the same host and port.
        // https://github.com/facebook/create-react-app/issues/2272#issuecomment-302832432
        devServer.app.use(noopServiceWorkerMiddleware(paths.publicUrlOrPath))

        return middlewares
      },
    }

    const devServer = new WebpackDevServer(serverConfig, compiler)
    // Launch WebpackDevServer.
    devServer.startCallback(() => {
      openBrowser(urls.localUrlForBrowser)
    })
    ;['SIGINT', 'SIGTERM'].forEach((sig) => {
      process.on(sig, () => {
        devServer.close()
        process.exit()
      })
    })

    if (process.env.CI !== 'true') {
      // Gracefully exit when stdin ends
      process.stdin.on('end', () => {
        devServer.close()
        process.exit()
      })
    }
  } catch (err: any) {
    if (err && err.message) {
      console.log(err.message)
    }
    process.exit(1)
  }
}

export default dev
